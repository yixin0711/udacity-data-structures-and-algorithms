This algorithm takes an array object (input_list) and an int object (number) as input and return the index of number in the input_list or -1 if not found. In this case the inputed list is rotated so we cannot do single comparison to determine the location. Instead, we need double pointers to make comparison. As other searching algorithms, we start from the middle of the array. If the target number is within two pointers, then we can narrow down our range by setting the end index or start index to the middle index. This algorithm also takes O(log n) time complexity since we are cutting the array a half in each loop. Also, it will not create extra space in further loops so the space complexity is O(1).